Hook함수를 잘 이해하는 것
    일반변수 --> 상태가 변할때 리렌더링 될 필요는 없고, 해당 컴포넌트가 리렌더링 되더라도 그 값을 계속 갖고 있지 않아도 되는 경우
    useState() --> 상태가 변환되고 리렌더링 되어야 한다면 사용
    useRef()--> 상태가 변할때 리렌더링 될 필요는 없는 해당 컴포넌트가 리렌더링 되더라고 
    그값을 계속 갖고 있어야 하는경 우
    useMemo()--> 특정 연산 결과 값을 리렌더링 될 때마다 실행시킬 필요가 없으면 사용

useEffect()
    특정 함수를 특정 상황에서만 실행시키고 싶을 때 사용한다
    예를 들어 컴포넌트가 최초 렌더링 된다면 
    컴포넌트가 렌더링이 될때마다
    컴포넌트가 삭제되기 직전에 함수를 실행시키고 삭제시켜줘

    인자를 두개 넘겨줘야 한다
    첫번째 자리에는 실행하고자 하는 함수 객체(익명함수,함수이름)
    함수 자체를 넘겨줘야 한다
    두번째 자리는 (의존성)배열
    만일 두번째 자리가 생략된다면 함수는 컴포넌트가 리랜더링 될때마다 실행된다
    
    만일 의존성 배열이 비어있는 배열이라면 최초 렌더링(mount 되었을때) 시에만 실행된다

    의존성 배열 안에 변수나 객체가 들어있다면 해당 변수 또는 객체가 변화했을 때만 실행된다!

    cleanup 함수
    useEffect() 의 함수 인자자리에 적혀있는 함수는
    렌더링 되고나서 실행되는 함수이며 그함수 속에 return 옆에 함수를 정의하면
    컴포넌트가 삭제되기전(mount 해제되기 전)실행시키고 컴포넌트가 삭제되는 함수가 된다


클래스형 컴포넌트
    class ParentPage extends Component{
        클래스형 컴포넌트에서는 해당 컴포넌트가 렌더링 되었을 때 무언가를 실행
        삭제되기 전에 무언가를 실행
        업데이트(변경사항이 있을때) 무언가를 실행하는 함수들을 자유롭게 정의할 수 있었다
    }

함수형 컴포넌트에서는 이러한 행위가 불가능해했는데 훅함수를 통해 생명주기 관리가 가능해졌다

보통 API를 통해서 이벤트를 등록할 때 , 삭제할때 많이 사용한다



useMemo()
    는 특정 연산 결과 값을 재사용
    useMemo() 함수 사용 결과는 해당 함수의 첫번째 인자 값으로 전달된 함수 속에서
    return 된 "값"이다

useCallback()
    함수의 첫번째 인자 자리에는 실행시키고자 하는 함수 객체를 전달한다
    두번재 인자 자리에는 의존성 배열을 전달한다

ussCallback()
    함수의 첫번째 인자 자리에는 실행시코가자 하는 함수 객체를 전달한다
    두번째 인자 자리에는 의존성 배열을 전달한다
    useCallback() 함수 사용 결과는 해당 함수 속에서 첫번째 인자로 전달된 "함수"이다


useCallback() 함수사용 결과는 함수 객체인데, 의존성 배열에 들어있는 변수가 변할때만
새롭게 만들어지는 함수 객체이다.그 함수의 객체를 다시 의존성 배여ㅑㄹ에 사용할때
동일한 함수임을 판단하기 위해서 사용한다

const a = usecallback(함수,[name,age]);

a는 함수객체이고, 리 렌더링 되더라도 의존성배열에 있는 name이나  age에 변화가 없다면
기존의 함수 객체를 그대로 사용한다
//주소값이 똑같아서 바꼈다고 인식을 안함

따라서 a가 의존성배열 안에서 쓰였을때
useEffect(함수,[a])
-->useEffect는 a가 변경되었을때만, a는 언제 새로운 함수객체가 되냐면
name하고 age가 변경될때만

const a = 함수

a는 함수 객체이고,리 렌더링되면 무조건 새로운 함수 객체이다
useEffect(함수,[a])
    리랜더링 되면 무조건 a에는 새로운 함수 객체가 대입되고,기존의 함수객체랑 다르기에
    무조건 useEffect 인자 속 함수가 실행된다
    //내용이 달라진다는게 아니라 정보를 가지고 있는 객체 주소가 달라진다 a00-> b00

useMemo(,[name,age])
a는 name 혹은 age가 바뀔때만 새롭게 대입되는 변수
name,age가 바뀌면 새로운 값이(return앞에) 대입되고

const a =useCallback(,[name,age])
a는 name혹은 age가 바뀔때만 새로운 함수객체가 대입되는 변수
name,age가 바뀌면 앞에있는 함수랑 내용이 똑같은 새로운 객체가 대입된다


값이냐 객체냐의 차이

memorization 함수는 무작정 사용한다고 효율적인 것은 아니다
의존성 배열에 들어있는 값이 만약 반드시 매번 바뀌는 값이다
memorization을 위해 이전의 값과 바뀐값을 비굑하느 작업자체가 무의미헤진다
(검사안해도 이전과 다르니까)
특정 상황에서 드물게 바뀌는 경우에 활용하는 것이 바람직하다


컴포넌트  memorization

memo(함수형 컴포넌트)

해당 컴포넌트는 부모의 state가 변화되어 부모가 re-rendering 되더라도 자신의 상태가
변함이 없다면 다시  rendering 하지 않는다(기존 return 된 컴포넌트를 그대로 사용한다)

값이냐 객체냐의 차이









